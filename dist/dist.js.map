{"version":3,"names":[],"mappings":"","sources":["dist.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.standalone = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lazy = require('./lazy');\n\nvar _map = require('./funcs/map');\n\nvar _flatten = require('./funcs/flatten');\n\nvar _filter = require('./funcs/filter');\n\nvar _from = require('./funcs/from');\n\nvar _chunk = require('./funcs/chunk');\n\nvar _reduce = require('./funcs/reduce');\n\nvar _take = require('./funcs/take');\n\nvar _drop = require('./funcs/drop');\n\nvar _uniq = require('./funcs/uniq');\n\nvar _zip = require('./funcs/zip');\n\nvar _consecutive = require('./funcs/consecutive');\n\nvar _difference = require('./funcs/difference');\n\nvar _intersection = require('./funcs/intersection');\n\nvar _aggregate = require('./funcs/aggregate');\n\nvar _object = require('./funcs/object');\n\nconst toEager = (fn, cplx = true) => cplx ? (collection, ...args) => (0, _lazy.lazy)(fn(...args))(collection) : (0, _lazy.lazy)(fn);\n\nexports.default = {\n  map: toEager(_map.map),\n  flatMap: toEager(_map.flatMap),\n  flatMapDeep: toEager(_map.flatMapDeep),\n  flatten: toEager(_flatten.flatten, false),\n  flattenDeep: toEager(_flatten.flattenDeep, false),\n  filter: toEager(_filter.filter),\n  reject: toEager(_filter.reject),\n  compact: toEager(_filter.compact, false),\n  fromPairs: toEager(_from.fromPairs, false),\n  chunk: toEager(_chunk.chunk),\n  reduce: toEager(_reduce.reduce),\n  take: toEager(_take.take),\n  takeWhile: toEager(_take.takeWhile),\n  drop: toEager(_drop.drop),\n  dropWhile: toEager(_drop.dropWhile),\n  uniq: toEager(_uniq.uniq, false),\n  uniqBy: toEager(_uniq.uniqBy),\n  zip: toEager(_zip.zip),\n  zipWith: toEager(_zip.zipWith),\n  consecutive: toEager(_consecutive.consecutive, false),\n  difference: toEager(_difference.difference),\n  differenceBy: toEager(_difference.differenceBy),\n  intersection: toEager(_intersection.intersection),\n  intersectionBy: toEager(_intersection.intersectionBy),\n  groupBy: toEager(_aggregate.groupBy),\n  countBy: toEager(_aggregate.countBy),\n  keys: toEager(_object.keys, false),\n  values: toEager(_object.values, false),\n  entries: toEager(_object.entries, false)\n};\n\n},{\"./funcs/aggregate\":2,\"./funcs/chunk\":3,\"./funcs/consecutive\":4,\"./funcs/difference\":5,\"./funcs/drop\":6,\"./funcs/filter\":7,\"./funcs/flatten\":8,\"./funcs/from\":9,\"./funcs/intersection\":10,\"./funcs/map\":11,\"./funcs/object\":12,\"./funcs/reduce\":13,\"./funcs/take\":14,\"./funcs/uniq\":15,\"./funcs/zip\":16,\"./lazy\":20}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.countBy = exports.groupBy = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst id = v => v;\n\nconst groupBy = exports.groupBy = (iteratee = id) => arg => {\n  const group = {};\n\n  return (0, _inference.inferAny)(() => {\n    const value = arg();\n\n    if ((0, _helpers.isEof)(value)) return value;\n\n    const key = iteratee(value);\n\n    if (group.hasOwnProperty(key)) {\n      group[key].push(value);\n    } else {\n      group[key] = [value];\n    }\n\n    return group;\n  });\n};\n\nconst countBy = exports.countBy = (iteratee = id) => arg => {\n  const group = {};\n\n  return (0, _inference.inferAny)(() => {\n    const value = arg();\n\n    if ((0, _helpers.isEof)(value)) return value;\n\n    const key = iteratee(value);\n\n    if (group.hasOwnProperty(key)) {\n      group[key] += 1;\n    } else {\n      group[key] = 1;\n    }\n\n    return group;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chunk = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst chunk = exports.chunk = n => arg => (0, _inference.inferArray)(() => {\n  const result = [];\n  let value = null;\n\n  do {\n    value = arg();\n    if ((0, _helpers.isEof)(value)) break;\n    result.push(value);\n  } while (n > result.length);\n\n  return result.length > 0 ? result : value;\n});\n\n},{\"../helpers\":17,\"../inference\":19}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.consecutive = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst DEFAULT_VALUE = {};\n\nconst consecutive = exports.consecutive = arg => {\n  let prevValue = DEFAULT_VALUE;\n\n  return (0, _inference.inferArray)(() => {\n    const x = prevValue === DEFAULT_VALUE ? arg() : prevValue;\n    const y = arg();\n\n    if ((0, _helpers.isEof)(y)) return y;\n\n    prevValue = y;\n\n    return [x, y];\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.differenceBy = exports.difference = undefined;\n\nvar _inference = require('../inference');\n\nvar _helpers = require('../helpers');\n\nconst id = v => v;\n\nconst difference = exports.difference = collection => {\n  const set = new Set(collection);\n  return arg => (0, _inference.inferArray)(() => {\n    let value;\n\n    do {\n      value = arg();\n    } while (set.has(value));\n\n    return value;\n  });\n};\n\nconst differenceBy = exports.differenceBy = (collection, iteratee = id) => {\n  const initSetValues = collection && collection.map(iteratee);\n  const set = new Set(initSetValues);\n\n  return arg => (0, _inference.inferArray)(() => {\n    let value;\n\n    do {\n      value = arg();\n      if ((0, _helpers.isEof)(value)) break;\n    } while (set.has(iteratee(value)));\n\n    return value;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dropWhile = exports.drop = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst drop = exports.drop = count => arg => {\n  let dropIndex = 0;\n\n  return (0, _inference.inferArray)(() => {\n    while (dropIndex < count) {\n      arg();\n      dropIndex += 1;\n    }\n    const value = arg();\n    return value;\n  });\n};\n\nconst dropWhile = exports.dropWhile = predicate => arg => {\n  let dropFinished = false;\n\n  return (0, _inference.inferArray)(() => {\n    if (dropFinished) {\n      return arg();\n    }\n\n    let value = null;\n\n    do {\n      value = arg();\n\n      const stopDropping = (0, _helpers.isEof)(value) || !predicate(value);\n\n      if (stopDropping) {\n        dropFinished = stopDropping;\n        break;\n      }\n    } while ((0, _helpers.isNotEof)(value));\n\n    return value;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compact = exports.reject = exports.filter = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst createFilter = condition => predicate => arg => (0, _inference.inferArray)(() => {\n  let value = null;\n\n  do {\n    value = arg();\n\n    if ((0, _helpers.isNotEof)(value) && predicate(value) === condition) {\n      return value;\n    }\n  } while ((0, _helpers.isNotEof)(value));\n\n  return value;\n});\n\nconst filter = exports.filter = createFilter(true);\nconst reject = exports.reject = createFilter(false);\nconst compact = exports.compact = filter(Boolean);\n\n},{\"../helpers\":17,\"../inference\":19}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flattenDeep = exports.flatten = undefined;\n\nvar _map = require('./map');\n\nconst flatten = exports.flatten = (0, _map.flatMap)(v => v);\nconst flattenDeep = exports.flattenDeep = (0, _map.flatMapDeep)(v => v);\n\n},{\"./map\":11}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromPairs = exports.from = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst from = exports.from = data => {\n  let index = 0;\n\n  return () => {\n    if (index < data.length) {\n      return data[index++];\n    }\n\n    return _helpers.eof;\n  };\n};\n\nconst fromPairs = exports.fromPairs = arg => (0, _inference.inferObject)(() => arg());\n\n},{\"../helpers\":17,\"../inference\":19}],10:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.intersectionBy = exports.intersection = undefined;\n\nvar _inference = require('../inference');\n\nvar _helpers = require('../helpers');\n\nconst id = v => v;\n\nconst intersection = exports.intersection = collection => {\n  const set = new Set(collection);\n\n  return arg => (0, _inference.inferArray)(() => {\n    let value;\n\n    do {\n      value = arg();\n    } while (!((0, _helpers.isEof)(value) || set.has(value)));\n\n    return value;\n  });\n};\n\nconst intersectionBy = exports.intersectionBy = (collection, iteratee = id) => {\n  const initSetValues = collection && collection.map(iteratee);\n  const set = new Set(initSetValues);\n\n  return arg => (0, _inference.inferArray)(() => {\n    let value;\n\n    do {\n      value = arg();\n    } while (!((0, _helpers.isEof)(value) || set.has(iteratee(value))));\n\n    return value;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],11:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flatMapDeep = exports.flatMap = exports.map = undefined;\n\nvar _from = require('./from');\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst map = exports.map = transform => arg => (0, _inference.inferArray)(() => {\n  const value = arg();\n  return (0, _helpers.isNotEof)(value) ? transform(value) : value;\n});\n\nconst flatMap = exports.flatMap = transform => arg => {\n  const stack = [arg];\n  const isOverDeepMaximum = stack => stack.length > 1;\n  const peek = stack => stack[stack.length - 1];\n\n  return (0, _inference.inferArray)(() => {\n    let value = null;\n\n    do {\n      const source = peek(stack);\n      value = source();\n\n      if ((0, _helpers.isEof)(value)) {\n        stack.pop();\n        continue;\n      }\n\n      if (isOverDeepMaximum(stack)) {\n        return value;\n      }\n\n      const transformedValue = transform(value);\n\n      if (Array.isArray(transformedValue)) {\n        const newSource = (0, _from.from)(transformedValue);\n        stack.push(newSource);\n        continue;\n      }\n\n      return transformedValue;\n    } while (stack.length > 0);\n\n    // eslint-disable-next-line\n    return value;\n  });\n};\n\nconst flatMapDeep = exports.flatMapDeep = transform => arg => {\n  const stack = [arg];\n  const isOverDeepMaximum = stack => stack.length > 1;\n  const peek = stack => stack[stack.length - 1];\n\n  return (0, _inference.inferArray)(() => {\n    let value = null;\n\n    do {\n      const source = peek(stack);\n      value = source();\n\n      if ((0, _helpers.isEof)(value)) {\n        stack.pop();\n        continue;\n      }\n\n      value = isOverDeepMaximum(stack) ? value : transform(value);\n\n      if (Array.isArray(value)) {\n        const newSource = (0, _from.from)(value);\n        stack.push(newSource);\n        continue;\n      }\n\n      return value;\n    } while (stack.length > 0);\n\n    // eslint-disable-next-line\n    return value;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19,\"./from\":9}],12:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.entries = exports.values = exports.keys = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst LOCAL_EOF = () => {};\n\nconst entriesGenerator = function (obj, localEof = true) {\n  if (!(0, _helpers.isObject)(obj)) {\n    return () => obj;\n  }\n\n  const EOF = localEof ? LOCAL_EOF : _helpers.eof;\n\n  const keys = Object.keys(obj);\n  let keyIndex = 0;\n\n  return () => {\n    if (keys.length > keyIndex) {\n      const key = keys[keyIndex++];\n      return [key, obj[key]];\n    }\n\n    return EOF;\n  };\n};\n\nconst createSequence = transform => {\n  const handler = arg => {\n    let seq = (0, _helpers.isObject)(arg) ? entriesGenerator(arg, false) : entriesGenerator(arg());\n\n    const iterator = () => {\n      let item = null;\n\n      do {\n        item = seq();\n\n        if (item === LOCAL_EOF) {\n          seq = entriesGenerator(arg());\n        }\n      } while (item === LOCAL_EOF);\n\n      return (0, _helpers.isNotEof)(item) ? transform(...item) : item;\n    };\n\n    return (0, _inference.inferArray)((0, _helpers.wrapSimpleSource)(iterator, false));\n  };\n\n  handler.__kve__ = true;\n\n  return Object.freeze(handler);\n};\n\nconst keys = exports.keys = createSequence(key => key);\nconst values = exports.values = createSequence((_key, value) => value);\nconst entries = exports.entries = createSequence((key, value) => [key, value]);\n\n},{\"../helpers\":17,\"../inference\":19}],13:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reduce = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\n// TODO: think how to improve it\nconst reduce = exports.reduce = (reducer, firstValue) => arg => {\n  let firstValUndefined = firstValue === undefined;\n  let flushNeeded = !firstValUndefined;\n  let result = firstValue;\n\n  return (0, _inference.inferAny)(() => {\n    result = firstValUndefined ? arg() : result;\n\n    const value = arg();\n    const eof = (0, _helpers.isEof)(value);\n\n    if (eof) {\n      const flushValue = flushNeeded ? result : value;\n      flushNeeded = false;\n      return flushValue;\n    }\n\n    flushNeeded = firstValUndefined = false;\n    result = reducer(result, value);\n\n    return result;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],14:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.takeWhile = exports.take = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst take = exports.take = count => arg => {\n  let itemsTaken = 0;\n\n  return (0, _inference.inferArray)(() => {\n    const value = arg();\n    itemsTaken += 1;\n    return itemsTaken <= count ? value : _helpers.eof;\n  });\n};\n\nconst takeWhile = exports.takeWhile = predicate => arg => (0, _inference.inferArray)(() => {\n  const value = arg();\n\n  if ((0, _helpers.isEof)(value) || !predicate(value)) {\n    return _helpers.eof;\n  }\n\n  return value;\n});\n\n},{\"../helpers\":17,\"../inference\":19}],15:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniqBy = exports.uniq = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nconst uniq = exports.uniq = arg => {\n  const set = new Set();\n\n  return (0, _inference.inferArray)(() => {\n    let value = null;\n\n    do {\n      value = arg();\n\n      if ((0, _helpers.isEof)(value)) {\n        return value;\n      }\n    } while (set.has(value));\n\n    set.add(value);\n\n    return value;\n  });\n};\n\nconst uniqBy = exports.uniqBy = propFn => arg => {\n  const set = new Set();\n\n  return (0, _inference.inferArray)(() => {\n    let value = null;\n    let propValue = null;\n\n    do {\n      value = arg();\n\n      if ((0, _helpers.isEof)(value)) {\n        return value;\n      }\n\n      propValue = propFn(value);\n    } while (set.has(propValue));\n\n    set.add(propValue);\n\n    return value;\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19}],16:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.zip = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _inference = require('../inference');\n\nvar _source = require('../source.factory');\n\nconst withFnDef = (v1, v2) => [v1, v2];\n\n// use source factory\nconst zip = exports.zip = data => arg => {\n  const anthSource = (0, _source.sourceFactory)(data, []);\n\n  return (0, _inference.inferArray)(() => {\n    const value = arg();\n    let anthSourceValue = anthSource();\n    anthSourceValue = (0, _helpers.isEof)(anthSourceValue) ? undefined : anthSourceValue;\n\n    return (0, _helpers.isEof)(value) ? value : [value, anthSourceValue];\n  });\n};\n\nconst zipWith = exports.zipWith = (data, withFn = withFnDef) => arg => {\n  const anthSource = (0, _source.sourceFactory)(data, []);\n\n  return (0, _inference.inferArray)(() => {\n    const value = arg();\n    let anthSourceValue = anthSource();\n    anthSourceValue = (0, _helpers.isEof)(anthSourceValue) ? undefined : anthSourceValue;\n\n    return (0, _helpers.isEof)(value) ? value : withFn(value, anthSourceValue);\n  });\n};\n\n},{\"../helpers\":17,\"../inference\":19,\"../source.factory\":21}],17:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst SOURCE_TYPES = exports.SOURCE_TYPES = Object.freeze({\n  COLLECTION: 'collection',\n  INV_SOURCE: 'inv_source',\n  SIMP_SOURCE: 'simp_source'\n});\n\nconst eof = exports.eof = Object.freeze(() => {});\nconst isEof = exports.isEof = value => value === eof;\nconst isNotEof = exports.isNotEof = value => value !== eof;\nconst isObject = exports.isObject = value => Object.prototype.toString.call(value) === '[object Object]';\nconst getSource = exports.getSource = src => {\n  if (Array.isArray(src)) {\n    return SOURCE_TYPES.COLLECTION;\n  }\n\n  return src && src.__source__;\n};\n\nconst wrapSource = exports.wrapSource = (fn, sourceType, freeze = true) => {\n  fn.__source__ = sourceType;\n  return freeze ? Object.freeze(fn) : fn;\n};\n\nconst wrapSimpleSource = exports.wrapSimpleSource = (fn, frz) => wrapSource(fn, SOURCE_TYPES.SIMP_SOURCE, frz);\nconst wrapInvocableSource = exports.wrapInvocableSource = (fn, frz) => wrapSource(fn, SOURCE_TYPES.INV_SOURCE, frz);\n\nconst toSource = exports.toSource = generator => (...args) => wrapSource(() => {\n  const gen = generator(...args);\n  return () => gen();\n}, SOURCE_TYPES.INV_SOURCE);\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generator = exports.repeat = exports.range = exports.lazySource = exports.fromPairs = exports.entries = exports.values = exports.keys = exports.countBy = exports.groupBy = exports.zipWith = exports.zip = exports.chunk = exports.uniqBy = exports.uniq = exports.dropWhile = exports.drop = exports.takeWhile = exports.take = exports.reduce = exports.compact = exports.reject = exports.filter = exports.differenceBy = exports.difference = exports.intersectionBy = exports.intersection = exports.consecutive = exports.flattenDeep = exports.flatten = exports.flatMapDeep = exports.flatMap = exports.map = exports.lazy = exports.eager = undefined;\n\nvar _lazy = require('./lazy');\n\nvar _map = require('./funcs/map');\n\nvar _flatten = require('./funcs/flatten');\n\nvar _filter = require('./funcs/filter');\n\nvar _from = require('./funcs/from');\n\nvar _chunk = require('./funcs/chunk');\n\nvar _reduce = require('./funcs/reduce');\n\nvar _take = require('./funcs/take');\n\nvar _drop = require('./funcs/drop');\n\nvar _uniq = require('./funcs/uniq');\n\nvar _zip = require('./funcs/zip');\n\nvar _consecutive = require('./funcs/consecutive');\n\nvar _difference = require('./funcs/difference');\n\nvar _intersection = require('./funcs/intersection');\n\nvar _aggregate = require('./funcs/aggregate');\n\nvar _object = require('./funcs/object');\n\nvar _generator = require('./sources/generator');\n\nvar _range = require('./sources/range');\n\nvar _repeat = require('./sources/repeat');\n\nvar _lazy2 = require('./sources/lazy.source');\n\nvar _eager = require('./eager');\n\nvar _eager2 = _interopRequireDefault(_eager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// funcs\nexports.eager = _eager2.default;\nexports.lazy = _lazy.lazy;\nexports.map = _map.map;\nexports.flatMap = _map.flatMap;\nexports.flatMapDeep = _map.flatMapDeep;\nexports.flatten = _flatten.flatten;\nexports.flattenDeep = _flatten.flattenDeep;\nexports.consecutive = _consecutive.consecutive;\nexports.intersection = _intersection.intersection;\nexports.intersectionBy = _intersection.intersectionBy;\nexports.difference = _difference.difference;\nexports.differenceBy = _difference.differenceBy;\nexports.filter = _filter.filter;\nexports.reject = _filter.reject;\nexports.compact = _filter.compact;\nexports.reduce = _reduce.reduce;\nexports.take = _take.take;\nexports.takeWhile = _take.takeWhile;\nexports.drop = _drop.drop;\nexports.dropWhile = _drop.dropWhile;\nexports.uniq = _uniq.uniq;\nexports.uniqBy = _uniq.uniqBy;\nexports.chunk = _chunk.chunk;\nexports.zip = _zip.zip;\nexports.zipWith = _zip.zipWith;\nexports.groupBy = _aggregate.groupBy;\nexports.countBy = _aggregate.countBy;\nexports.keys = _object.keys;\nexports.values = _object.values;\nexports.entries = _object.entries;\nexports.fromPairs = _from.fromPairs;\nexports.lazySource = _lazy2.lazySource;\nexports.range = _range.range;\nexports.repeat = _repeat.repeat;\nexports.generator = _generator.generator;\n\n// xor, xorBy\n\n// sources\n\nexports.default = {\n  lazy: _lazy.lazy,\n  map: _map.map,\n  flatMap: _map.flatMap,\n  flatMapDeep: _map.flatMapDeep,\n  flatten: _flatten.flatten,\n  flattenDeep: _flatten.flattenDeep,\n  consecutive: _consecutive.consecutive,\n  intersection: _intersection.intersection,\n  intersectionBy: _intersection.intersectionBy,\n  difference: _difference.difference,\n  differenceBy: _difference.differenceBy,\n  filter: _filter.filter,\n  reject: _filter.reject,\n  compact: _filter.compact,\n  reduce: _reduce.reduce,\n  take: _take.take,\n  takeWhile: _take.takeWhile,\n  drop: _drop.drop,\n  dropWhile: _drop.dropWhile,\n  uniq: _uniq.uniq,\n  uniqBy: _uniq.uniqBy,\n  chunk: _chunk.chunk,\n  zip: _zip.zip,\n  zipWith: _zip.zipWith,\n  groupBy: _aggregate.groupBy,\n  countBy: _aggregate.countBy,\n  keys: _object.keys,\n  values: _object.values,\n  entries: _object.entries,\n  fromPairs: _from.fromPairs,\n  lazySource: _lazy2.lazySource,\n  range: _range.range,\n  repeat: _repeat.repeat,\n  generator: _generator.generator\n};\n\n},{\"./eager\":1,\"./funcs/aggregate\":2,\"./funcs/chunk\":3,\"./funcs/consecutive\":4,\"./funcs/difference\":5,\"./funcs/drop\":6,\"./funcs/filter\":7,\"./funcs/flatten\":8,\"./funcs/from\":9,\"./funcs/intersection\":10,\"./funcs/map\":11,\"./funcs/object\":12,\"./funcs/reduce\":13,\"./funcs/take\":14,\"./funcs/uniq\":15,\"./funcs/zip\":16,\"./lazy\":20,\"./sources/generator\":22,\"./sources/lazy.source\":23,\"./sources/range\":24,\"./sources/repeat\":25}],19:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyInference = exports.inferAny = exports.inferObject = exports.inferArray = undefined;\n\nvar _helpers = require('./helpers');\n\nconst INFERENCE = {\n  ARRAY: lz => {\n    const result = [];\n    let value = null;\n\n    do {\n      value = lz();\n\n      if ((0, _helpers.isEof)(value)) break;\n\n      result.push(value);\n    } while ((0, _helpers.isNotEof)(value));\n\n    return result;\n  },\n  OBJECT: lz => {\n    const shape = {};\n    let value = null;\n\n    do {\n      value = lz();\n\n      if ((0, _helpers.isEof)(value)) break;\n\n      shape[value[0]] = value[1];\n    } while ((0, _helpers.isNotEof)(value));\n\n    return shape;\n  },\n  ANY: lz => {\n    let value = undefined;\n\n    do {\n      const bufferValue = lz();\n      if ((0, _helpers.isEof)(bufferValue)) break;\n      value = bufferValue;\n    } while ((0, _helpers.isNotEof)(value));\n\n    return value;\n  }\n};\n\nconst infer = type => fn => {\n  fn.__infer__ = type;\n  return Object.freeze(fn);\n};\n\nconst inferArray = exports.inferArray = infer(INFERENCE.ARRAY);\nconst inferObject = exports.inferObject = infer(INFERENCE.OBJECT);\nconst inferAny = exports.inferAny = infer(INFERENCE.ANY);\nconst applyInference = exports.applyInference = func => func.__infer__(func);\n\n},{\"./helpers\":17}],20:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazy = undefined;\n\nvar _source = require('./source.factory');\n\nvar _inference = require('./inference');\n\nconst lazy = exports.lazy = (...funcs) => {\n  if (funcs.length === 0) {\n    return v => v;\n  }\n\n  return collection => {\n    const source = (0, _source.sourceFactory)(collection, funcs);\n    const func = [source, ...funcs].reduce((arg, fn) => fn(arg));\n    return (0, _inference.applyInference)(func);\n  };\n};\n\n},{\"./inference\":19,\"./source.factory\":21}],21:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sourceFactory = undefined;\n\nvar _helpers = require('./helpers');\n\nvar _from = require('./funcs/from');\n\nconst fallbackSource = () => _helpers.eof;\n\nconst sourceFactory = exports.sourceFactory = (data, funcs) => {\n  const { COLLECTION, INV_SOURCE, SIMP_SOURCE } = _helpers.SOURCE_TYPES;\n\n  switch ((0, _helpers.getSource)(data)) {\n    case COLLECTION:\n      return (0, _from.from)(data);\n    case INV_SOURCE:\n      return data();\n    case SIMP_SOURCE:\n      return data;\n    default:\n      break;\n  }\n\n  const butler = funcs[0];\n\n  if ((0, _helpers.isObject)(data) && butler.__kve__) {\n    return (0, _from.from)([data]);\n  }\n\n  return fallbackSource;\n};\n\n},{\"./funcs/from\":9,\"./helpers\":17}],22:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generator = undefined;\n\nvar _helpers = require('../helpers');\n\nconst genGenerator = (fn, count = Infinity) => {\n  let index = 0;\n\n  return () => {\n    if (index < count) {\n      return fn(index++);\n    }\n\n    return _helpers.eof;\n  };\n};\n\nconst generator = exports.generator = (0, _helpers.toSource)(genGenerator);\n\n},{\"../helpers\":17}],23:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazySource = undefined;\n\nvar _helpers = require('../helpers');\n\nvar _source = require('../source.factory');\n\nconst lazySource = exports.lazySource = (...funcs) => {\n  // TODO: cover it with test\n  if (funcs.length === 0) {\n    return (0, _helpers.wrapInvocableSource)(v => v);\n  }\n\n  return collection => (0, _helpers.wrapInvocableSource)(() => {\n    const source = (0, _source.sourceFactory)(collection, funcs);\n    const sequence = [source, ...funcs].reduce((arg, fn) => fn(arg));\n    return sequence;\n  });\n};\n\n},{\"../helpers\":17,\"../source.factory\":21}],24:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.range = undefined;\n\nvar _helpers = require('../helpers');\n\nconst rangeGenerator = (start, end = Infinity, step = 1) => {\n  const basis = end - start >= 0 ? 1 : -1;\n  const correctedStep = step * basis;\n  const evalCondition = basis > 0 ? (s, e) => s < e : (s, e) => s > e;\n\n  return () => {\n    if (evalCondition(start, end)) {\n      const buff = start;\n      start += correctedStep;\n      return buff;\n    }\n\n    return _helpers.eof;\n  };\n};\n\nconst range = exports.range = (0, _helpers.toSource)(rangeGenerator);\n\n},{\"../helpers\":17}],25:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.repeat = undefined;\n\nvar _helpers = require('../helpers');\n\nconst repeatGenerator = (what, count = Infinity) => {\n  let index = 0;\n\n  return () => {\n    if (index < count) {\n      index += 1;\n      return what;\n    }\n\n    return _helpers.eof;\n  };\n};\n\nconst repeat = exports.repeat = (0, _helpers.toSource)(repeatGenerator);\n\n},{\"../helpers\":17}]},{},[18])(18)\n});\n"],"file":"dist.js"}